WARNING: Before submitting, to ensure I had replicable code, I copied and pasted the set seed commands incorrectly (inside the mutation and crossover functions). By doing this, it always selects the same loci, and the solution does not improve much. I have re-uploaded the code as "tsp_new_correct_seed" without the extra set seed commands.


As for the greedy algorithm, I implemented an algorithm that selects the next city as the first city in the shortest subsequent path with k cities. Since k is arbitrary, I implemented a recursive structure to generate all possible paths of length k. The algorithm, with k equal to the total number of cities, would yield the optimal solution; however, it has a computational cost that grows exponentially, so I limited k to 3.

For the genetic algorithm, as suggested by Vida Gallo, I started with an initial population generated from the solution provided by the greedy algorithm. In addition to the mutation and crossover methods discussed in class, I added a mutation that selects a locus in the parent and creates offspring by swapping the value with the next k cities (similar to scramble mutation), then choosing the optimal offspring. The idea behind this mutation was to leverage the greedy solution by swapping cities that were already in the same “zone.” I stopped at 1000 generations, but the solution generally converges towards the optimum.
